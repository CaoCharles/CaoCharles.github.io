{"pages":[{"title":"關於","date":"2018-12-08T18:14:31.307Z","path":"about/index.html","text":"查爾斯的天地動機這是一個我整理知識及分享心得的部落格。 碩一升碩二的暑假，來到信邦電子實習，遇到了好主管，我就開啟了寫程式的開關，在實習過程中，愛上了寫程式DeBug的感覺，與其在其他制式的部落格發文，不如自己建個資料庫吧，於是這個網頁就誕生啦! 動力深深感受到類神經網路與機器學習帶給人們對模型不一樣的想像，我想要盡可能的把統計方法用於這些模型之中，希望藉由這個部落格，撰寫自己的讀書心得，以及整理在學校舉辦的深度學習讀書會，希望能精進我表達能力和程式的撰寫能力。 學經歷學歷: 政治大學統計所 碩士 台北教育大學 數學暨資訊教育學系 學士 實習經歷: 2018 信邦電子 暑期實習AI工程師 2018 政大統計諮詢中心 資深助理 獲獎經歷： 2018 國泰大數據競賽 第二名 2018 國泰大數據競賽 創新應用獎"},{"title":"分類","date":"2018-08-28T09:23:35.000Z","path":"categories/index.html","text":""},{"title":"tags","date":"2018-12-08T18:18:24.000Z","path":"tags/index.html","text":""}],"posts":[{"title":"職場透視營 II","date":"2018-12-08T17:41:19.000Z","path":"職場透視營-心得/","text":"【職涯中心】職場透視營 II 時間 : 2018/12/08 9:00-18:00 地點 : 總院270406 上午場 講師 : 退休的和藹伯伯 經歷 : 職業生涯諮詢顧問 改變 主動的(有想法) 被動的(主管要求) 公司招募流程(以鴻海集團為例) 投遞履歷 履歷審核 (篩選-人才庫) 面試徵選 (人才儲備) 任用流程 寄發通知書 報到 履歷與公司招募 找工作的第一步 入門/初階工作，少則數十份，多則以百計 履歷篩選 1.人資(初步/複選/電話)&gt;&gt;徵才部門 2.徵才部門(團隊/主管)&gt;&gt;面試 履歷到面試時間 當天 ~ 1、2月 通知已收到履歷或是否面試 視公司而定 面試機率 2%(美國) 機器人篩選 關鍵字(產業趨勢、工作內容) 投履歷是過程，面試才是目標 履歷到碎紙機(或Del鍵)的捷徑 沒有寫到應徵項目 一次應徵很多不同類型的職缺 在技能選項完全沒有自己會的項目 沒有寫自傳或不知所云 剛畢業、沒有工作經驗就應徵主管職缺 人資看履歷平均時間 : 約40秒 我想被看到 - 客製化履歷 獨特性、與眾不同，不要人云亦云 只有4%的社會新鮮人會客製化履歷 用自我行銷的方式寫履歷 行銷四要素 產品 : 個人經歷盤點(知己 : 認識自己) 推廣 : 目標職務研究(知彼 : 了解產業與工作內容) 價格 : 自我價值 通路 : 選取相關素材(履歷表、自傳) 原來主管這麼想(需加強的就業能力) 穩定性及抗壓性 良好的個人工作態度 表達與溝通能力 強烈的學習意願與高度可塑性 團隊合作能力 知己知彼 - 客製化履歷的基礎 認識自己 自我盤點 專長能力 : 相關就讀科系、實習、證照 性格、人際關係 : 社團、競賽、打工、經驗 興趣 : 本科專業、長期投注的課外活動 表格化、量化 職場硬實力 學歷(含輔系、學程、校內外進修) 經歷(以實習、兼職工作為主) 專長技能 語文溝通能力 相關證照 電腦、網路軟硬體 專業儀器的使用 職場軟實力 人際關係 同理心 團隊合作 領導力/指導性 時間管理 相互討論/談判協商 問題解決 發現與問題解決能力 分析邏輯 獨立思考 學習能力 表達溝通 情緒智力 EQ 下定決定/決策力 語言能力的掌握 認識工作與產業 收集資料 : 網站、書籍、雜誌、PTT 人事廣告 : 入門到五年工作經驗 實務經驗分享 : 師長、學長姐、就業博覽會 實習機會 : 學校、寒暑假、政府部門、企業 求職前要先了解內容 企業面 職務面 企業文化差異 蝦皮 - 麥肯錫企業文化 Pchome - 本土電商文化 客製化履歷的下一步 1.對這份工作的了解 2.我有那些能力可以做好這份工作 3.未來的職涯規劃與這份工作的相關性 履歷表的格式下午場實習大叔(The Internship) 《實習大叔》（英語：The Internship）是一部2013年上映的由肖恩·利維執導，文斯·沃恩 和Jared Stern編劇，文斯·沃恩和肖恩製片的美國喜劇劇情片。由文斯·沃恩和歐文·威爾森主演。 心得中年失業的兩個大叔，與一群實習生一同來到google，他們與社會新鮮人不同，有著豐富的銷售經驗，卻也不了解現在最熱門的電腦與APP，實習生需要組成團隊進行競賽，最後與其他也是個性古怪的3人和經理人一同組成隊伍，在競賽過程中，經歷了許多不同年代的價值觀碰撞，我覺得這就跟我們現在遭遇的情形相似，每個人都年輕過，都有過崇高的夢想，但隨著課業跟現實，往往變得厭世，缺乏動力的年輕人，所以我很喜歡兩個大叔的心態，就算學歷不如人，也時常用自己擅長的溝通能力將不足的地方補齊，勇往直前勇於追夢。 每次看完這部電影的感想都不盡相同，與其當個沒有想法的人，我寧願專注做自己想做的事，不要侷限在小框框裡面，有甚麼有趣的事情就嘗試做做看，就算沒做完也不見得是件壞事，遇到挫折才知道難處，面對自己不擅長的事情，與其放棄不如勇敢面對，跟不同領域的人合作，可以看到自己的盲點，就像影片裡的大叔，只有行銷方面的專業，也是透過各種構通及學習才越來越厲害，也因為善於構通，在影片裡也認識了google專職的工程師，不起眼的地方往往會疏忽，也因此得到了許多幫助，就像與諮詢的案主溝通一樣，他們雖然不擅於統計，但也有各自的專長，有時候與他們聊天反而會看到更多社會的縮影，真的還蠻有趣的，希望我以後也能繼續這樣下去，不要只侷限在機器學習的世界裡。 Career 就業情報經驗分享 本科專業 統計 應數 資管 資科 提供網站勞動統計查詢網 職能發展平台","tags":[{"name":"work experience","slug":"work-experience","permalink":"https://caocharles.github.io/tags/work-experience/"}],"categories":[{"name":"演講心得","slug":"演講心得","permalink":"https://caocharles.github.io/categories/演講心得/"}]},{"title":"國泰大數據競賽心得","date":"2018-11-28T20:18:50.000Z","path":"國泰大數據競賽心得/","text":"國泰大數據競賽心得競賽網頁 緣起升碩二前的暑假，正在匆忙的進行實習趕稿，那個時候大概是正在學習怎麼製作聊天機器人的語料吧!突然手機上出現訊息通知，原來是展源在密我，問我有沒有空參加比賽，我就這樣踏進了這趟旅程。 初賽我們第一次討論好像是在新莊的咖啡廳吧，那個時候其實大家也都沒空參加講座，我好像剛忙完實習的樣子?就在那邊討論了一個下午，我們對於初賽的資料其實不太知道怎麼下手，那天大致討論完後，好像就交給展源清理資料，填補遺失值，我們就回去了。 到了要交件的前三天，我才開始趕工分析模型，那個時候算是對Python有點小小成就的新手吧，我就在網路上觀看機器學習的課程，用了超哥教過的隨機森林模型，和暑假跟柏龍討論已久的類神經網路，不過準確率依舊在9成初徘徊，最後在網路上收尋到XGBoost，測試後發現樹模型的建模速度很快，在調校上也容易操作，就這樣在短短幾天中漸漸的將模型訓練出來，不知道為甚麼，我覺得模型總是在半夜的時候會變得準確，就這樣慢慢的習慣熬夜了。 繳件過後其實沒有想太多，畢竟我們連講座都沒有去聽，用的也不是講座裡提供的模型，想說就當作機器學習的練習吧，還好最後順利晉級，沒有拖累隊友，耶! 複賽複賽時國泰提供遠端的服務，讓我以後也想要自己建個遠端來玩，因為看到別人的教授提供遠端電腦給其他同學用，真的蠻羨慕的，剛好就趁複賽的時候也來碰碰遠端，還好我們隊伍分工的很清楚，展源負責清理資料，宜謙負責撰寫說明跟整理文檔，我就可以用這些資料在半夜的時候慢慢做事，思索著到底該使用哪些資料建立模型。 不過複賽的資料很雜，而我們又不太了解保險商品內容，在資料整理那部份花了大半時間來查詢資訊，常常三個人討論完放空，不過這個舉動也影響我們決賽的行為(跑去概念店找靈感)，或許冥冥之中就是這樣，好模型是要講求緣分的，我在一個邊打瞌睡邊打code的情形下，找到了還不錯的變數欄位，就這樣開始根據這個構想把主附約的模型各別訓練出來，最後加上繁雜的敘述統計，整份文件說明也靠著展源和宜謙，最終寫滿了15頁書面報告繳件給主辦單位。 決賽看到決賽公布名單，那時的我正在上課，我邊喝著鮮奶茶邊顫抖著雙手，從來沒有想像沒正式比賽過的我，也能走到這一步，到這裡其實很感動，這就是我考研究所的初衷，如今的我，也正在實踐我的夢想，就這樣邊喝著奶茶邊思考著下一步該怎麼做。 知道決賽主題後的第一次討論，我們在研究室寫滿了好幾次白板，也沙盤推演了各種過程好幾次，其中我們也一直思索著推薦商品後所提供的誘因適不適合，在茫茫的收尋之中，無意間點開了國泰的概念店網站，我依稀有印象在那裡聽過，而且這個網頁給人一種清新的感覺，我們三個後來就決定找個假日探險去了。 概念店網址 我們約了繳件前的禮拜天，去到位於忠孝新生的概念店，3個人依序點了不同的飲品，我還是點了鮮奶茶，坐在那邊感受國泰概念店的氣氛，在這邊真的蠻適合討論保險，也很適合進行課程活動之類的，討論差不多後，我跟展源假扮成上班族的身分去諮詢保單，那因為我從小就是國泰的保戶，但我也不知道我有哪些保單，我就以我的資訊進行詢問，雖然諮詢的客服小姊姊一開始用驚訝疑惑的眼神看著我們兩個人，不過隨著時間慢慢閒聊跟諮詢，客服姊姊也漸漸開始幫我分析我的保單，在這諮詢之中，我逐漸了解到保險合約內容的適當性，也開始瞭解通常諮詢會遇到的問題有那些，要是複賽時有了解這些資訊，其實很多步驟都不用清理了，套句阿祥大大說的，你沒有足夠的Domain Knowledge是很難當好資料科學家的，我們用了網路上各種方法來訓練模型，卻時常忘記放入這變數的意義是甚麼，這也算是我從展源身上學習到的地方吧，展源很注重欄位的解釋，一定要能夠合理解釋才能放進模型，而我們卻常常一股腦將擁有的資訊全部丟入模型訓練，像是我們到決賽才知道投資型保單有限定年齡跟繳費方式，它跟一般保障保單是不同的，而且國泰的許多網頁也是將其險種分開，這也影響了我們後來推薦系統的建立，與小姐姐熱絡的聊天之後，我拿了厚厚的保險推薦回來，後來大家一起去了松菸走走，最後搭車回政大把整個流程跟時間規劃討論出來，這一步討論到我跟展源回家時都已經錯過了末班車，只能搭計程車回家，兩人各噴了500，不過我想這時候我已有足夠大的信心能將這次決賽完成，就完成了第二次討論。 繳件前的禮拜一，我們討論要如何設計流程與呈現畫面的最終版，之後我查詢了許多推薦系統介面的論文，很多都需要一定的UI程式設計，我看著看著，發現網路上有許多漂亮的畫面呈現在我眼前，我就心想著我還有多少時間，可不可以把所有事情都推掉專心做一次就好，就順利的把助教課跟教授開會排開，花了一個晚上，到禮拜二早上8點大概學習了60%的操作，就這樣回宿舍睡覺了，睡醒後大概下午，接著就繼續排版製作我的第一個UI介面，也順便讓展源回去休息，這樣我才能跟宜謙拍神秘計畫的影片(哈哈)。 繳件前的禮拜三，我難得早起去上清祥的課，深怕他是評審又一直看到我沒來上課，我最後還是到課堂上繼續製作我的ADOBE XD，這時候大概進入完成40%介面，這天我後來就繼續在國貿所的討論室製作，轉眼間一天又過去。那時候初版的製作大概長這樣，不過看到自己的作品一步步慢慢製作出來，就有更多動力繼續做下去了，旁邊顯示的保險都是小姐姐推薦給我的。 繳件前的禮拜四五，這兩天很簡單，就是一直趕趕趕，中間過程我都沒有睡覺，整個Demo製作完後，開始要寫複賽的QA，展源負責製作PPT，我們兩個腦力激盪了一整晚跟早，終於在最後整合出PPT，並將QA一同交出，我回去洗澡完也接著上讀書會，不過想當然的睡倒在椅子上。 繳件後的幾天，我們從擬稿到請同學來觀摩，過程很匆忙，感謝柏龍跟初初，願意花時間給予我們回饋跟建議，也不斷的練習台風、口號，希望在決賽場上有好表現。 決賽當日前往國泰金融會議中心!!!!! 我穿著著第一次套裝的西裝，腦中不斷演練待會要報告的詞語，如何在舞台上不要怯場，將整個隊伍在總結的時候帶出氣勢，展源抽到了第4組，跟柯P一樣的號碼，這時我內心多了幾分平穩，也許是半夜練稿的時候我都會看柯P的演講的關係吧，這次我們的主題「革命發生，改變成真」，就那麼剛好發生在我們身上，我們上台報告的時候，看到別老師一直觀看我們講解核心理念，頻頻的點頭如搗蒜，真的給予我很大的信心，演示系統的時候看到台下開心的掃描QR CODE，又給予了我很大的勇氣，在宜謙和展源介紹完之後，就一路由我從回饋機制講到QA時間，但是這時候我站在台上的時候心情卻很雀躍，這就是我的舞台呀，我的夢想呀，聽到評審給予我們極高的評價之後，我認真思索著評審提出的問題並回答，其實有些問題是我們來不及製作完UI時就有想到的，也曾經在我們的沙盤推演中出現過，不過還好在QA時評審有提出，讓我們能更完整講解我們的系統。 等待其他組報告中~ 團隊合照 緊張的頒獎時間啦，我們在不經意的時候聽到評審說到我們名字，我們在還搞不懂得獎名稱的時候上台頒獎，我想應該是我們的作品真的DEMO出來大家很喜歡吧，不然其他組的PPT我都好喜歡呀，但似乎還差一個名次這次比賽才完美。 在前面頒發三個獎之後，中途又經過了一段等待時間，到了最最最刺激的時候，這個時候誰會拿前3名真的很難預料，這次參賽隊伍水準超高，各種動畫網頁呈現，當我看到評審翻開名冊後的眼神，那隊伍名稱一定很奇怪，而且好像跟剛剛有重複，沒錯!就是我們泰泰我喜歡你R，一想到這4個月努力的成果有收穫，內心狂奮不已，開心的上台領獎。 感想說長不長，說短不短的四個月，其中伴隨著助教課，跟教授開會，十月時接了三個統計諮詢，不過我想時間是可以壓榨出來，只要有奶茶，一切都沒問題。我們一路走來都是意外，意料之外的意外，應該沒有人覺得我們這組是來報名拚名次的。也因為這樣，我們越能心無旁騖地往正確的方向邁進，每次討論時，都經歷漫長的沙盤推演及眾人不斷的討論，最後整合意見，將每次結果記錄下來。在這之中，我發現跟展源和宜謙討論時，我們往往都有不同領域的思考跟想法，我把我的經驗跟邏輯講解給隊友們聽，你們也會給予我不同領域的思考邏輯，這是我在系上學不到的經驗，像有時候你們會在一些設計上的缺陷給予我建議，這是我自己一個人做不到的事，就這樣我們一路奮鬥到了決賽場上，靠著我們的優勢報告我們的商品內容，最後也拿到了不錯的名次。我想這次瘋狂的競賽經驗，對於我們未來也都有很大幫助，之後想進國泰應該直接拿畢業證書跟競賽獎狀就沒問題了吧。 最後附上一首歌曲代表這陣子的努力 給我一奶茶再給我一盞燈說敖就熬我有的是時間我不想在未來的日子裡留下遺憾沒有目標 給我一奶茶再給我一盞燈說做就做我有的是時間我不想在未來的日子裡看著過去懊悔萬分","tags":[{"name":"Competition","slug":"Competition","permalink":"https://caocharles.github.io/tags/Competition/"},{"name":"CathyLife","slug":"CathyLife","permalink":"https://caocharles.github.io/tags/CathyLife/"}],"categories":[{"name":"國泰人壽","slug":"國泰人壽","permalink":"https://caocharles.github.io/categories/國泰人壽/"},{"name":"國泰大數據競賽","slug":"國泰人壽/國泰大數據競賽","permalink":"https://caocharles.github.io/categories/國泰人壽/國泰大數據競賽/"}]},{"title":"商業簡報製作","date":"2018-11-10T15:42:01.000Z","path":"商業簡報製作/","text":"簡報課in國泰 (11/10) 時間 : 2018/11/10 13:30-15:30 地點 : 國泰演講廳 茶點 : 貓茶町 Lecture 1 商業簡報製作簡報內容 講師 : 黃紹峰 課程 : 商業簡報製作 聽得懂、坐得住的簡報 只有15分鐘要怎麼做簡報 14 mins 報告流程安排 Hello 30s 簡單介紹自己隊伍 Problem 1m 闡述問題 : 定義問題越簡單越好 Solution 4m F,A,B Feature 功能 Advantage 優點 Benifit 效益 Demo 4m30s Steps before/after Feedback 1m Who backs you up? Review 3m Recap,sum up 接棒的問題 上台的人要怎麼湊在一起，如何接棒 避免重複性的話語 重複演練減少重複性 10mins QA Take notes(準備紙筆) Appendix(附件) 製作簡報第1步(不要套用模板)Make your temps 查爾斯的模板 第2步(字型) 選擇沒有襯線的字型比較好看 Google NOTO Sans(思源體) 微軟正黑 微軟雅黑 字的大小(28以上)、粗細、間距 用字的大小來排表(做出圖表效果) 第3步(訊息) Message = Info - Noise 強調重點(顏色、粗細、) 次重點做弱化(做一個透明度80%的灰片把資訊覆蓋住) 第4步(圖片) 選擇適合的圖片 選擇png去背好的圖片 用圖去搜圖 使用photoshop去背完再貼上 png 很棒，有去背 ICON 可以找跟大樹的ICON(感覺蠻不錯的) 快速找取現成的ICON nounproject(向量檔) https://thenounproject.com/ flaticon(查爾斯愛用的) https://www.flaticon.com/ undraw(圖) https://undraw.co/ 找的ICON要有一致性 漸層ICON(使用photoshop) ICON下面最好加一行註解 第5步(Tone色調) 設備的新舊 舊的設備(白底黑字較好) 新的設備(黑底白字較好) 螢幕很大(黑底白字較好) 顏色上的取用 配合公司的主題顏色 選擇美的、耐看的顏色 符合自己主題的顏色 Powerpoint只吃MP4(比賽應該用不到) 第6步(Diagrams數據及資料) 圖表最好都重新製作一次 使用圖的方式表達(圓餅圖) 不能亂用，會被清祥罵 第7步(Animation) 我也不想用(迪士尼的看起來還不錯耶) 簡報沒內容可以用動畫跟華麗背景克服(尤其是清祥的課) 第8步(Details 我最愛的細節) Alignment(一致性) 字體、大小、圖表、ICON、中英文 Use gradient() 不要使用設計建議 忠於自己的美感 Use less 3D() 3D過時 不要反射(不流行) Position Before v.s. After Leave some balnk Don’t roll slides On Time!!!!! 要做逐字稿，減少贅詞的使用，加強說話方式(很難但是有用) 可以用不講話來強調 想要表達自己做很多事 放很多東西，或是密集的表格 不用講太多 就跟寫清祥的作業一樣 好看的排版","tags":[{"name":"PPT","slug":"PPT","permalink":"https://caocharles.github.io/tags/PPT/"}],"categories":[{"name":"國泰人壽","slug":"國泰人壽","permalink":"https://caocharles.github.io/categories/國泰人壽/"},{"name":"簡報課程在國泰","slug":"國泰人壽/簡報課程在國泰","permalink":"https://caocharles.github.io/categories/國泰人壽/簡報課程在國泰/"}]},{"title":"商業簡報台風","date":"2018-11-10T15:42:00.000Z","path":"商業簡報台風/","text":"簡報課in國泰 (11/10) 時間 : 2018/11/10 15:30-17:00 地點 : 國泰演講廳 茶點 : 貓茶町 Lecture 2 簡報商業台風簡報內容 講師 : Ben ou 課程 : 簡報商業台風 流程 30秒電梯理論 語出驚人 好的開始是成功的一半 郁達夫文集(快短命) 快，痛快 短，簡明扼要 命，不離命題 短小精悍 抓住根本，直達主體 提綱挈領，化繁為簡 提煉觀點 觀點要獨特響亮 歸納要緊湊，不超過三條 麥肯錫金字塔方法 MECE原則-參考網頁 麥肯錫解決問題7步驟 解決問題的不是與生俱來的天賦，而是可以透過自我訓練培養而成，你也能像麥肯錫人一樣，倍速解決問題。 金字塔架構 金字塔方法 金字塔原理四個基本特徵 金字塔結構 SDS結果法 先講結論 再講經過 最後再重複結論 注意事項 開頭 破題 邏輯結構 記憶點 使用者場景 互動&amp;張力 結尾Key Take Away 至少讓觀眾記住一個畫面 峰尾效應 記憶點 有記憶點的結束! Mamba out! 再一個記憶點的結束! Kobe Bryant Slow Motion Shooting Compilation","tags":[{"name":"PPT","slug":"PPT","permalink":"https://caocharles.github.io/tags/PPT/"}],"categories":[{"name":"國泰人壽","slug":"國泰人壽","permalink":"https://caocharles.github.io/categories/國泰人壽/"},{"name":"簡報課程在國泰","slug":"國泰人壽/簡報課程在國泰","permalink":"https://caocharles.github.io/categories/國泰人壽/簡報課程在國泰/"}]},{"title":"人工智慧第4周筆記","date":"2018-10-08T09:30:19.000Z","path":"人工智慧第4周筆記/","text":"人工智慧與應用筆記4第四周其他組報告老師的講義大家都在看莫凡講解類神經網路 CSM 演算法增加node的流程 (有7個步驟) The proposed CSM learning procedure 判斷是不是熟悉的case When we encounter a new case (a new input/output relationship), we first check if it is familiar to us. If it is, there is no spontaneous learning effort involved. Later the new case is merged into our knowledge system. If it is not, we might cram this unfamiliar case first. The cramming results in a strict rule with respect to this unfamiliar case. Then we will soften the strictness of the new case and do our best to merge the new case into our knowledge system. 面對的問題如果是曾經有過的資料，則會選擇相關的資訊回應。 面對的問題如果是未曾有過的資料，則會選擇增加一個新回應。 ASLFN (3層的類神經網路 輸入-&gt;隱藏-&gt;輸出層) The Adaptive Single-hidden Layer Feed-forward Neural Networks (ASLFN, i.e., the amount of adopted hidden nodes is variable) (references: Tsaih 1993; Tsaih 1998; Tsaih and Cheng 2009; Huang, Yu, Tsaih and Huang Tsaih 2014; Kuo, Lin, and Hsu 2018) 2-class categorization problem and binary inputs {−1, 1}^𝑚 Activation Function (激活函數) tanh, the hyperbolic tangent activation function, is used in all hidden nodes. The Activation Value of Hidden Nodes (隱藏層的激活值) 激活函數不能亂給，會有梯度爆炸的情形發生。 $𝐱^𝑐≡(𝑥_1^𝑐,𝑥_2^𝑐, …,𝑥_𝑚^𝑐 )T：𝑡ℎ𝑒 input vector of the 𝑐^th case$ $𝑤_{𝑖0}^{𝐻}：the threshold value of the 𝑖^th hidden node$ $𝑤_𝑖𝑗^𝐻：the weight between the 𝑖^th hidden node and the 𝑗^th input node$ $𝐰_𝑖^𝐻≡(𝑤_𝑖0^𝐻,𝑤_𝑖1^𝐻,𝑤_𝑖2^𝐻, …,𝑤_𝑖𝑚^𝐻 )^T$; $𝐰^𝐻≡{({𝐰_1^𝐻}^T,{𝐰_2^𝐻}^T,…,{𝐰_𝑝^𝐻}^T)}^T$ The Activation Value of the Output Node (輸出層的激活數值) Parameters and Indexes (參數) N denotes the number of all reference observations m denotes the number of input nodes p denotes the number of adopted hidden nodes; p equals 1 at the beginning and is adaptive $𝑦^𝑐$ denotes the desired output of the $𝑐^th$ case, with 1.0 and -1.0 being the desired outputs of classes 1 and 2 n denotes the $𝑛^th$ stage of handling n reference observations ${(𝐱^1, 𝑦^1), (𝐱^2, 𝑦^2), …, (𝐱^𝑛, 𝑦^𝑛)}$, and $𝐈(𝑛)$ is the set of indices of these observations. At the $𝑛^th$ stage, the loss function $𝐸_𝑛 (𝐰)≡\\frac{∑_{𝑐=1}^{𝑛}(𝑓(𝐱^𝑐,𝐰)−𝑦^𝑐 )^2}{𝑛}+10^{-3}‖𝐰‖^2$ $𝐈(𝑛)≡𝐈_1 (𝑛)∪𝐈_2 (𝑛)$, where$𝐈_1(𝑛)$ and $𝐈_2(𝑛)$ are the set of indices of n given cases in classes 1 and 2 At the $𝑛^th$ stage with the reference observations ${(𝐱^𝑐, 𝑦^𝑐): 𝑐∈𝐈(𝑛)}$, we look for an acceptable SLFN, in which the condition L regarding ${𝑓(𝐱^𝑐,𝐰), ∀ 𝑐∈𝐈(𝑛)}$ is satisfied. The condition 𝐿 regarding ${𝑓(𝐱^𝑐,𝐰), ∀ 𝑐∈𝐈(𝑛)}$ The Learning Goal (學習目標) At the $𝑛^{th}$ stage, through minimizing the loss function $𝐸_𝑛 (𝐰)≡\\frac{∑_{𝑐=1}^{𝑛}(𝑓(𝐱^𝑐,𝐰)−𝑦^𝑐 )^2}{𝑛}+10^{-3} (∑_{𝑖=0}^{𝑝}{(w_𝑖^o)^2} + ∑_{𝑖=1}^{𝑝}∑_{𝑗=0}^{𝑚}(𝑤_{𝑖𝑗}^{𝐻})^2)$,the learning goal is to seek $𝐰$ where $𝑓(𝐱^𝑐,𝐰)&gt;𝜈,∀ 𝑐∈𝐈_1 (𝑛)$ and $𝑓(𝐱^𝑐,𝐰)≤−𝜈,∀ 𝑐∈𝐈_2(𝑛)$, with $1&gt;𝜈&gt;0$. An alternative goal of learning is to seek 𝐰 that satisfies the condition 𝐿 regarding ${𝑓(𝐱^𝑐,𝐰), ∀ 𝑐∈𝐈(𝑛)}$ When $𝛼&gt;𝛽$ is satisfied, $𝑓(𝐱^𝑐,𝐰)≥𝑣 ,∀ 𝑐∈𝐈_1(𝑛)$and $𝑓(𝐱^𝑐,𝐰)≤−𝑣,∀ 𝑐∈𝐈_2(𝑛)$ can be achieved by directly adjusting $𝐰^𝑜$ according to the following: The Proposed CSM Learning Algorithm Step 1: Initialize a SLFN with one hidden node with a randomized w. Obtain the first reference observation $(𝐱^1, 𝑦^1)$. Set $n = 2$. Step 2: If $n &gt; N$, STOP. Step 3: Present the n reference observations ${(𝐱^𝑐, 𝑦^𝑐): c ∈ I(n)}$. Step 4: If the condition L regarding ${𝑓(𝐱^𝑐,𝐰), ∀ 𝑐∈𝐈(𝑛)}$ is satisfied, go to Step 7.1. Step 5: Save $w$. Step 6: Apply the weight-tuning mechanism to $min_{𝐰}{⁡𝐸(𝐰)}$ to adjust $w$ until one of the following two cases occurs: a. If the condition L regarding {𝑓(𝐱^𝑐,𝐰), ∀ 𝑐∈𝐈(𝑛)} is satisfied, go to step 7.1. b. If an unacceptable result is obtained, then Restore w Let $p + 1 → p$ and add to the existing SLFN the new $𝑝^{th}$ hidden node with the following $𝐰_𝑝^𝐻$ and $𝐰_𝑝^𝑜$: Step 7.1: Apply the weight-tuning mechanism one hundred times to minimizing $𝐸_𝑛(𝐰)$ to adjust $𝐰$, while keeping the condition L regarding ${𝑓(𝐱^𝑐,𝐰), ∀ 𝑐∈𝐈(𝑛)}$ satisfied. Step 7.2: Calculate $𝑔_𝑘^′ ∀ 𝑘$, where $𝐰_𝑘^{′}≡ 𝐰 – ({𝑤_𝑘^𝑜, 𝐰_𝑘^𝐻})$, $𝑓(𝐱^𝑐,𝐰_𝑘^′ )≡𝑓(𝐱^𝑐,𝐰)- 𝑤_{𝑘}^{𝑜}𝑎_{𝑘}^{𝑐}$,$𝛼_𝑘^′≡ min_{𝑐ϵ𝐈_1(𝑛)}⁡𝑓(𝐱^𝑐,𝐰_𝑘^′ )$, $𝛽_𝑘^′≡max_{𝑐ϵ𝐈_2(𝑛)}⁡𝑓(𝐱^𝑐,𝐰_𝑘^′)$, and $𝑔_𝑘^′≡ 𝛼_𝑘^′−𝛽_𝑘^′$. Step 7.3: If $- \\theta &gt;max_{1&lt;k&lt;p}{g_{k}^{‘}}$, where $\\theta$ is a given constant, go to Step 2. Step 7.4: If $max_{1&lt;k&lt;p}^⁡{𝑔_𝑘^′} &gt; 0$, prune the $𝑖^{th}$ hidden node, in which 𝑖 is the first index of $arg max_{1&lt;k&lt;p}𝑔_{𝑘}^{′}$, $p-1-&gt;p$, $𝐰_𝑖^′-&gt;w$, and go to Step 7.1. Flowchart of the proposed algorithm (流程圖) Explanation of the Proposed CSM Learning Algorithm (解釋CSM學習演算法) Step 6 conducts the cramming mechanism. The Appendix shows the properness of the cramming mechanism. All hidden nodes use the same activation function, but some of them have the heterogeneity due to their large associated weights. The total amount of used hidden nodes will be large if new hidden nodes are added frequently. Step 7.1 and Step 7.5.c are designed to soften the heterogeneity. At Step 6, Step 7.1 and Step 7.5.c, the weight-tuning mechanism is applied to minimizing $𝐸_𝑛(𝐰)$ to adjust weights, while there is the regularization term in $𝐸_𝑛(𝐰)$. The total amount of used hidden nodes will be large if new hidden nodes are added frequently. Step 7.2 to Step 7.5 are designed to merge the unfamiliar case into the knowledge system via reducing the total amount of used hidden nodes. The pruning issue file shows the logic of the merging mechanism. The irrelevant hidden node The irrelevance examination mechanism No under-fitting The Regularization term in $𝐸_𝑛(𝐰)$ Regarding the overfitting issue, the regularization term in the loss function $𝐸_𝑛(𝐰)$ may prevent the model from doing too well on training data. 筆記 演算法的停止準則與學習目標不一定會有關係 Cramming (硬背下去)Softening (軟化)Merging (合併)","tags":[{"name":"AI","slug":"AI","permalink":"https://caocharles.github.io/tags/AI/"}],"categories":[{"name":"碩二課程","slug":"碩二課程","permalink":"https://caocharles.github.io/categories/碩二課程/"},{"name":"人工智慧與應用","slug":"碩二課程/人工智慧與應用","permalink":"https://caocharles.github.io/categories/碩二課程/人工智慧與應用/"}]},{"title":"進階創新科技技術(第一周)","date":"2018-09-26T02:38:16.000Z","path":"進階創新科技技術/","text":"進階創新科技技術共編(第一個禮拜) 每周的錄音檔都放在這裡 https://drive.google.com/drive/folders/1jQl4cLGAwekYkz6gSCDlR7wwxA4dqbzP?usp=sharing 曾老師 (要求) 爬蟲 PTT、FB 特定網站 (文章) 參考文獻 (有興趣的主題) 老師只有上六週的課程 文字分析為主 結構化資料也可以 Kagle、政府的公開資料、Researched Data 從NLP上知道商品的行情 專家系統是甚麼? 第一周 要啥的資料集，NLTK 一組報一篇 NLP 的研究、論文、文獻探討 下禮拜就可以做這件事 我有錄音嘻嘻 臭噁男博士生(人家只是年齡比較大ㄅ…) 我說禮拜一那個 HI-EXPEND 是啥意思 (花比較多錢來讀書的人) 說得好，我華山派… 要幹嘛 語意分析 情感分析 網路聲量分析，都不容易 Sources of Big Data In addition to accumulation of traditional data of transactions: Data warehousing (資料倉儲) Cloud computing Social network Internet of Things (IOT) The business data volume is therefore increasing dramatically. Some important attributes may be embedded in or mined from the big volume of data. Therefore, data management issues for the big data are getting 蝦咪挖歌的. Common Framework of Big Data 六個V(自己查) Volume Velocity Variety Veracity Value 深V 我的帥照(屁啦) 非監督式學習 牛奶跟啤酒(關聯式資料)- 監督式學習 一生只督你一人 有Y那一條的可以督 督的越準、越夯(XGBOOST、DNN) 決策樹(Desision tree) (最老的那種) 增強式學習深度學習(類神經網路)AI的三大應用 語言辨識 Prescriptive Analysis 名詞:指導性分析 釋義:根據預測分析的結果，總結及建議不同結果的優化行動。 方法:透過預測分析結果，進行決策 NTLK (好像這才是重點) 找一篇paper來報告 textminingonline.nltk 載一下套件 網頁在這 載好久 123456789101112# 語料庫在這from nltk.corpus import brownbrown.words()[0:10]brown.tagged_words()[0:10]len(brown.words())dir(brown)# 斷句# 斷字tokens = word_tokenize(text) Tokenizers 好多Token，好想玩桌遊。(傻眼….) Token -&gt; 璀璨寶石第三堂課 Part-Of-Speech Tagging-1 最重要的文字分析之一 …投影片都有(也是) Part of speech tagging-2 . 123456from nltk.corpus import treebanklen(treebank.tagged_sents())train_data = treebank.tagged_sents()[:3000]print(train_data)test_data = treebank.tagged_sents()[3000:]print(test_data) 竟能如此優秀 &lt;3(謝東森) 助教精華(身材跟柏龍一樣)還蠻可愛的 需要加入記憶的結構 裝備很重要嗎 ? … … 助教除了聲音檔都可以幫我們爬 柏龍想抓AV女優圖(乾我闢是) 表特版抓圖(我好像有抓過) 我抓過西斯&lt;3(想要++) (太讚啦~) https://hackmd.io/6RIZ7tcyRymbihSUfCyIEw?view 助教剛剛說甚麼模型是最差的 ? 容易過度配飾的模型很差(應該吧)(適拉幹) 87萬張圖(好猛)變成8萬張而已 感覺就跟AI相機一樣 混淆矩陣(到底會不會進複賽呢~好刺激) 一個對話機器人 AI is A Brand’s New Face Mind the tech Details Know the difference between conversation AI and conventional chatbots Integrate Key Data Sets Crawler &amp; Data Cleanup1.爬蟲，隨機抽資料2.採用Python packages或 BASH shells皆可3.實驗室有PTT的爬蟲資料4.建議先學習基本linux指令5.高頻字與低頻字，都比不上可以清理因素的字 結論 幸好還有助教… 有人想跟博班一組ㄇ 我們四個一組不是嗎 NLP的文章(要找啥)-各自找在混一波嗎 產品的聲量(上游不太知道通路購買的消費者資料) topical model 我的鮮奶茶機器人 下禮拜的作業 找出分析NLP的方法嗎 ? 我先讀東森說的那兩篇，一些小摘要、心得和 murmur 記錄在這邊","tags":[{"name":"Pytorch","slug":"Pytorch","permalink":"https://caocharles.github.io/tags/Pytorch/"}],"categories":[{"name":"碩二課程","slug":"碩二課程","permalink":"https://caocharles.github.io/categories/碩二課程/"},{"name":"進階創新科技技術","slug":"碩二課程/進階創新科技技術","permalink":"https://caocharles.github.io/categories/碩二課程/進階創新科技技術/"}]},{"title":"統研深度學習讀書會","date":"2018-09-20T15:43:20.000Z","path":"統研深度學習讀書會/","text":"讀書會簡介大家好，這是我和立諭發起的讀書會，這個讀書會的目的是希望透過討論及分享來學習Machine Learning + Deep Learning，希望大家以後不要失業(來自東森的提醒) 先備知識 微積分(微分吧) 線性代數(向量輸入後的傳導及運算) 我們這學年的進度大致簡單介紹如下(暫定) 上學期 一開始先帶大家入門程式，但還不確定要從 Keras 或是 TensorFlow 入手 之後大家就每周做個作業，然後也要看個課程 課程方面應該以李宏毅的 Machine Learing 為主，他的課有以下特點 強調無痛入門，而且涉及的領域很廣，圖像及語音辨識、語意分析等等 上課方式有趣，基本上不會有枯燥的感覺 更重要的是李老師上課講的都是很新的內容，總之入門真的推薦 實作方面的資源很多，再慢慢介紹 大家有時間的話可以報名一些比賽，例如黑克松或是 Kaggle 討論實作上的技巧、觀念及問題 Scikit-Learn (機器學習 ML 套件)，比較次要，但還是希望大家能大致了解，下學期的多變量會輕鬆許多 寒假寒假大家可能很忙，但希望大家還是能撥點時間看些相關的東西 林軒田的機器學習基石跟技法 蠻理論的不過大家是碩士會理論應該的所以還是硬著頭皮看吧 講的東西其實都蠻原始的，有些東西其實已經沒人在用了 但是起源的東西我覺得聽一聽多少會有幫助 可能會聽到崩潰，應該是我太笨(可能只有AI真正懂) 聽說其實作業超爆難(by 資科-劉昭麟教授) 但是大家也不用寫作業，就大家自己看一看就好(吧) 下學期碩一下課業會挺重的，但好像也還好，多變量這門課如果上學期有在讀書會學到東西其實應該會蠻輕鬆的 論文探討，如果是很新的希望我們能把它實作出來看看 期望大家有找到自已想做的項目，我們很樂意一起討論或是提供幫助，最好的情況是你們可以指導我們嘻嘻","tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://caocharles.github.io/tags/Deep-Learning/"}],"categories":[{"name":"讀書會","slug":"study-group","permalink":"https://caocharles.github.io/categories/study-group/"}]},{"title":"深度學習","date":"2018-08-28T16:12:21.000Z","path":"深度學習/","text":"類神經網路 歷史人工智慧最早出現於1950年代。人工智慧的目標是希望能讓電腦像人一班思考與學習。被視為人工智慧之父的圖靈(Alan Mathison Turing)，提出了有名的圖靈測試:人類與機器對話，如果人類無法根據這些對話過程判斷對方是人或機器，即通過測試，認為這台電腦具有人工智慧。 隨著AI的發展日益茁壯，1980年代(Jhon Searle)，提出了對人工智慧的分類方式: 強人工智慧(Strong AI) : 機器與人具有完整的認知能力。 弱人工智慧(Weak AI) : 機器設計看起來具有智慧即可。 而深度學習是人工智慧中，現今成長最快的領域，隨著電腦的普及以及其CPU、GPU運算能力增強，我們可以透過世界上各個資料庫收集大量資料，將資料整理成類神經網路的格式，藉由模擬人類神經網路的運作方式，加上數學的演算法進行更新參數，就可以讓電腦學習分辨日常生活的事物，常見的深度學習架構，如多層感知器MLP、深度神經網路DNN、卷積神經網路CNN、遞迴神經網路RNN。 而這些深度學習的架構應用在視覺辨識、語音辨識、自然語言處理、生物醫學等領域，皆有非常好的效果。 人工智慧現在已廣泛運用在我們的日常生活之中，像是手寫辨識、圖像辨識、語音辨識，幾乎都存在於人手一台的手機之中，還有更進一步的運用，如自動駕駛，透過硬體上的更新，我們可以裝設感測器感應車子周圍的環境狀況，加上圖像辨識，並整合成資訊讓電腦判斷是否停車或繼續行駛，透過演算法讓電腦知道該如何做決定，到最後將會實現在市區行駛之中，隨著科技越來越進步，深度學習所應用的領域就越來越廣。 類神經網路 簡介[維基百科] 類神經網路簡稱（英語：Artificial Neural Network，ANN），簡稱神經網路（Neural Network，NN）或類神經網路，在機器學習和認知科學領域，是一種模仿生物神經網路（動物的中樞神經系統，特別是大腦）的結構和功能的數學模型或計算模型，用於對函式進行估計或近似。神經網路由大量的人工神經元聯結進行計算。大多數情況下人工神經網路能在外界資訊的基礎上改變內部結構，是一種自適應系統，通俗的講就是具備學習功能。 現代神經網路是一種非線性統計性資料建模工具。典型的神經網路具有以下三個部分： 結構（Architecture）結構指定了網路中的變數和它們的拓撲關係。例如:神經網路中的變數可以是神經元連接的權重（weights）和神經元的激勵值（activities of the neurons）。 激勵函式（Activity Rule）大部分神經網路模型具有一個短時間尺度的動力學規則，來定義神經元如何根據其他神經元的活動來改變自己的激勵值。一般激勵函式依賴於網路中的權重（即該網路的參數）。 學習規則（Learning Rule）學習規則指定了網路中的權重如何隨著時間推進而調整。 上圖為一個簡單的多層感知器，我們利用這個網路 類神經網路 應用 應用 手寫辨識 利用Python下tensorflow模組中的MNIST資料，收集了數萬筆掃描過的圖檔及標籤，我們可以利用各種類神經網路模型建立分類器模型，依據模型的特性加以訓練，並可將訓練過的模型儲存，用來預測手寫板上的數字。 圖像辨識 現今電腦辨識一般的圖片已經等同於人類的辨識率，甚至在反應的速度上會超過人類，但在動態影像的辨識度還有加強的空間，透過各種演算法的測試與改進，最終將會應用在自動駕駛等應用上。 自然語言處理 自然語言(Nature Language Processing, NLP)，是讓電腦學習理解人類所說的話語與文字，透過分析詞性，計算其詞向量等等，並運用樸素貝氏分類器將句子分類，來分析日常對話的含意，其產出有現在熱門的聊天機器人及FB所提供的(Facebook Messenger Platform)和line所推出的(Messaging API)。 AI與大數據的應用只會越來越深、越來越廣、越來越快，只要對科技發展有興趣的人，就可以踏入這塊領域了解AI的偉大。","tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://caocharles.github.io/tags/Deep-Learning/"}],"categories":[{"name":"深度學習","slug":"deep-learning","permalink":"https://caocharles.github.io/categories/deep-learning/"}]},{"title":"EM演算法","date":"2018-08-28T09:31:35.000Z","path":"EM演算法/","text":"參考網址Maximum Likelihood from Incomplete Data via the EM Algorithm 最大期望演算法（Expectation-maximization algorithm，又稱期望最大化算法）在資料分析中常用於分群，在給定群數及機率模型下，去尋找觀測值變數間的所隱藏的訊息，可用此演算法來估計機率模型中的參數估計或遺失值填補。 名詞介紹 樣本: $x$ 概似函數: $L(\\theta|x)=p(x|\\theta)$ 目的: 找到能讓 $L(\\theta|x)$ 最大化的參數 我的想法就是找到符合我們樣本資料的”最大”概似函數的機率模型參數，以往都是假設好機率模型中的參數，並計算其MLE，現在透過樣本及樣本所隱藏的隱變數，來推導適合這些樣本的模型參數。 思考 argument : $y$ (遺失值或是隱變數) complete-data likelihood : $L(\\theta|x,y)=p(x,y|\\theta)$ 加入隱變數後完整的概似函數 What about $max_\\theta L(x,y)$? need to recursively update y and $\\hat\\theta$? E步驟(更新y)根據現在給定的模型參數及樣本觀測值，我們去計算其log完整概似函數的期望值如下:$$Q(\\theta|\\theta^{(t)})\\equiv E_y[log p(x,y|\\theta)|x,\\theta^{(t)}]$$ M步驟(更新參數$\\theta$)最大化E步驟獲得的期望值$$\\theta^{(t+1)} = arg max_\\theta Q(\\theta|\\theta^{t})$$ 重複上述過程直到收斂 EM推導 $X:observed \\space data$ $Y:latent\\space variable$ $Log\\space likelihood \\space function$ $$ l(\\theta) $$ $$= lnP(X|\\theta) $$ $$= ln\\sum_yP(X,y|\\theta) $$ $$= ln(\\sum_yP(X,y|\\theta))\\frac{Q(y)}{Q(y)}$$ $$\\ge\\sum_yQ(y)ln\\frac{P(X,y|\\theta)}{Q(y)} $$ $$\\because log \\in concave\\space by\\space Jensen’s\\space inequality $$ $$(解決ln\\sum 不好計算的問題，Q:機率分配) $$ $$= E_Q(ln\\frac{P(X,y|\\theta)}{Q(y)})$$ 在$Jensen’s \\: inequality 中，當E(x)中，x=常數時，等號成立。$ $$\\Rightarrow\\frac{P(X,y|\\theta)}{Q(y)}=c \\in Constant，且\\sum_yQ(y)=1$$ $$\\Rightarrow\\sum_yP(X,y|\\theta)=c\\sum_yQ(y)=c$$ $$\\Rightarrow Q(y)=\\frac{P(X,y|\\theta)}{\\sum_yP(X,y|\\theta)}=P(y|x_i,\\theta)$$， $$Q:在樣本給定下之隱藏變數條件分布$$ $$\\therefore E_Q(ln\\frac{P(X,y|\\theta)}{Q(y)})=E_y(ln\\frac{P(X,y|\\theta)}{P(y|x_i,\\theta)}|X,\\theta)$$ $$\\theta^{(t+1)}=arg\\max\\limits_\\theta l(\\theta)\\Longleftrightarrow arg\\max\\limits_\\theta\\sum_{y}P(y|x_i,\\theta^{(t)})ln\\frac{P(X,y|\\theta)}{P(y|x_i,\\theta^{(t)})}$$ $$\\: \\: \\Longleftrightarrow arg\\max\\limits_\\theta\\sum_{y}P(y|x_i,\\theta^{(t)})lnP(X,y|\\theta)=E_y(lnP(X,y|\\theta)|X,\\theta^{(t)})=Q(\\theta|\\theta^{(t)})$$ $$\\therefore E-step :Find \\: Q(\\theta|\\theta^{(t)})$$ $\\Longleftrightarrow$ Find the expectation of the complete-data loglikelihood with respect to the missing data y given the observed data x and the current parameter estimates $\\theta^{(t)}$. $$M-step=\\theta^{(t+1)}=arg\\max\\limits_\\theta Q(\\theta|\\theta^{(t)})$$ EM收斂性 範例1197 animals are distributed multinomially into four categories with cell-probabilities$(\\frac{1}{2}+ \\frac{\\theta}{4}, \\frac{(1-\\theta)}{4}, \\frac{(1-\\theta)}{4}, \\frac{\\theta}{4})$, where $\\theta \\in (0,1)$is unknown Observed Data:$$x=(x_1,x_2,x_3,x_4)=(125,18,20,34)$$ Likelihood:$$L(\\theta；x)=\\frac{n!}{x_1!x_2!x_3!x_4!}(\\frac{1}{2}+\\frac{\\theta}{4})^{x_1}(\\frac{1}{4}-\\frac{\\theta}{4})^{x_2}(\\frac{1}{4}-\\frac{\\theta}{4})^{x_3}(\\frac{\\theta}{4})^{x_4}$$ Find MLE by maximizing loglikelihood Now use EM to find MLE 假設我們的隱藏變數在a裡面，令$y=x_{11}+x_{12}$ 完整的變數擴展為$(x_{11},x_{12},x_{2},x_{3},x_{4})$有5個 初始其參數 $(\\frac{1}{2}, \\frac{\\theta}{4}, \\frac{1}{4}-\\frac{\\theta}{4}, \\frac{\\theta}{4})$ 其概似函數如下 $$L(\\theta；x)=\\frac{n!}{x_{11}!x_{12}!x_2!x_3!x_4!}(\\frac{1}{2})^{x_{11}}(\\frac{\\theta}{4})^{x_{12}}(\\frac{1}{4}-\\frac{\\theta}{4})^{x_{2}+x_{3}}(\\frac{\\theta}{4})^{x_{4}}$$ E 步驟 給定機率模型參數$\\theta^{(t)}$和$(x_1,x_2,x_3,x_4)$，$$x_{11}=\\frac{2x_{1}}{2+\\theta}\\quad and \\quad x_{12}=\\frac{\\theta x_{1}}{2+\\theta}$$ 推導Q函數(令$y=x_{12}$)$$Q(\\theta |\\theta^{(t)})=E_y[log p(x,y|\\theta)|x, \\theta^{(t)}]$$ $$=E_y[(x_{12}+x_{4})log\\theta +(x_{2}+x_{3})log(1-\\theta)|x,\\theta^{(t)}]$$ $$=(E_y[x_{12}|x, \\theta^{(t)}]+x_{4})log\\theta +(x_{2}+x_{3})log(1-\\theta)$$ $$=(\\frac{\\theta^{(t)}x_{1}}{2+\\theta^{(t)}}+x_{4})log\\theta + (x_{2}+x_{3})log(1-\\theta)$$ 其中$$x_{12}|_{x,\\theta^{(t)}}\\sim Binomial(x_{1},\\frac{\\theta^{(t)}}{2+\\theta^{(t)}})$$ $$x_{12}^{(t)}=E_y[x_{12}|x,\\theta^{(t)}]=\\frac{\\theta^{(t)}x_{1}}{2+\\theta^{(t)}}$$ M 步驟 對Q函數進行微分 給定$(x_{11},x_{12},x_{3},x_{4},x_{5})$ $$\\theta^{(t+1)}=\\frac{x_{12}^{(t)}+x_{4}}{x_{12}^{(t)}+x_{2}+x_{3}+x_{4}}$$ 重複以上步驟到參數迭代至穩定 R 實作12345678910111213mult = function(theta, x, n)&#123; tmp = theta for(i in 1:n)&#123; # E-step x12 = x[1]*(theta/ (2 + theta)) # M-step theta = (x12 + x[4])/(x12 + x[2] + x[3] + x[4]) tmp = c(tmp, theta) &#125;&#125;x=c(125, 18, 20, 34)mult(0.1, x, 10) 範例2範例3假設現在有兩枚硬幣A、B 我們用一枚公正的硬幣來決定，投擲 A 或 B 硬幣 依據結果，投擲 A 或 B 硬幣 1次，記錄其結果 反覆進行n次，最終可得到類似如下結果: 10111011…. 1表示正面，0表示反面 如果我們今天只能觀察到最終結果，無法知道每一次投擲來自哪一枚硬幣，該如何估計出兩個硬幣出現正面機率? : Observed Data : $X=(x_1,x_2,…,x_n), x_i:正面出現次數$A、B 出現正面機率 : $\\theta =(p,q)$ $1^{\\circ}$ 從MLE想法出發 概似函數 :$$L(\\theta|X)=P(X|\\theta)=\\prod_{i=1}^nP(x_i|\\theta)$$ $$\\hat p=\\frac{使用A硬幣骰到正面次數}{使用A硬幣總投擲次數}$$ $$\\hat q=\\frac{使用B硬幣骰到正面次數}{使用B硬幣總投擲次數}$$ 但因為我們並不知道 $x_i$來自哪個硬幣(機率模型)，所以無法進行計算。 $2^{\\circ}$ 嘗試添加隱藏變數，使其變成complete data，運用EM演算法 根據observed data，我們無從得知 $x_i$來自哪個硬幣(機率模型)， 因此我們添加一個隱藏變數 $y_i$，其表示 $x_i$ 來自哪個硬幣，$Y=(y_1,y_2,…,y_n)$ $y_i = 1$ or $2$，$x_i|y_{i}=1 \\sim Ber(p_{1})$，$x_i|y_{i}=2 \\sim Ber(p_{2})$ E-step : $$\\Rightarrow Q(\\theta|\\theta^{(t)})=E_y[ln(p(x,y|\\theta))|x,\\theta ^{(t)}]=E_y[\\sum_{i=1}^{n}ln(p(y_i|\\theta)p(x_i|y_i,\\theta))|x,\\theta^{(t)}]$$ $$=\\sum_{i=1}^{n}E_y[ln(p(y_i|\\theta)p(x_i|y_i,\\theta))|x,\\theta^{(t)}]=\\sum_{i=1}^{n}\\sum_{y_i=0}^{1}[ln(p(y_i|\\theta)p(x_i|y_i,\\theta))p(y_i|x_i,\\theta^{(t)} )]$$ $$=\\sum_{i=1}^{n}\\sum_{j=0}^{1}[ln(p(y_i=j|\\theta)p(x_i|y_i,\\theta))p(y_i=j|x_i,\\theta^{(t)} )]$$ 其中$p(y_i=j|x_i,\\theta^{(t)} )$ : 在第t次迭代下，當前數據來自哪個硬幣的機率 Q-step : $$\\frac{\\partial Q}{\\partial p}=\\frac{\\partial (\\sum_{i=1}^{n}ln(\\frac{1}{2}p^{x_i}(1-p)^{1-x_i})p(y_i=1|x_i,\\theta^{(t)} )}{\\partial p}$$ $$=\\frac{\\partial (\\sum_{i=1}^{n}ln(\\frac{1}{2})+x_iln(p)+(1-x_i)ln(1-p)p(y_i=1|x_i,\\theta^{(t)} )}{\\partial p}$$ $$=\\sum_{i=1}^{n}(\\frac{xi}{p}-\\frac{(1-x_i)}{1- p})p(y_i=1|x_i,\\theta^{(t)} )=0$$ $$\\Rightarrow p^{(t+1)}=\\frac{\\sum_{i=1}^{n}x_ip(y_i=1|x_i,\\theta^{(t)})}{\\sum_{i=1}^{n}p(y_i=1|x_i,\\theta^{(t)})}$$ $$\\frac{\\partial Q}{\\partial q}=0$$ 同理可得,$$q^{(t+1)}=\\frac{\\sum_{i=1}^{n}x_ip(y_i=2|x_i,\\theta^{(t)})}{\\sum_{i=1}^{n}p(y_i=2|x_i,\\theta^{(t)})}$$ $3^{\\circ}$ 綜觀以上結果，可以發現實際上我們只需要計算出$p(y_i=j|x_i,\\theta^{(t)} )$，就可以拿來進行EM迭代。 $\\Rightarrow$ 給定初始值$(p^{(0)},q^{(0)})$，計算出$p(y_i=j|x_i,\\theta^{(0)} )$，代入更新參數$p^{(t+1)},q^{(t+1)}$，重複迭代，直到收斂或者達到自行給定tolerance內. $4^{\\circ}$ 若改成依據結果，連續投擲 A 或 B 硬幣 10次，記錄其結果 反覆進行n次，最終可得到類似如下結果: 1表示正面，0表示反面 最終Q-step 的參數公式 :$$p^{(t+1)}=\\frac{\\sum_{i=1}^{n}x_ip(y_i=1|x_i,\\theta^{(t)})}{\\sum_{i=1}^{n}10p(y_i=1|x_i,\\theta^{(t)}}$$ $$q^{(t+1)}=\\frac{\\sum_{i=1}^{n}x_ip(y_i=2|x_i,\\theta^{(t)})}{\\sum_{i=1}^{n}10p(y_i=2|x_i,\\theta^{(t)})}$$ Python 實作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import numpy as npimport pandas as pdfrom scipy import stats# 5組硬幣投擲結果(n=5,k=10)，1代表正面，0代表反面observations = np.array([[1, 0, 0, 0, 1, 1, 0, 1, 0, 1], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1], [1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 0, 1, 1, 1, 0, 1]])da=pd.DataFrame(observations, index=[\"第一次\",\"第二次\",\"第三次\",\"第四次\",\"第五次\"])da.columns = [1,2,3,4,5,6,7,8,9,10];da###def em_single(priors,observations): \"\"\" EM算法-單次疊代 ------------ priors:[theta_A,theta_B] observation:[m X n matrix] Returns --------------- new_priors:[new_theta_A,new_theta_B] :param priors: :param observations: :return: \"\"\" counts = &#123;'A': &#123;'H': 0, 'T': 0&#125;, 'B': &#123;'H': 0, 'T': 0&#125;&#125; theta_A = priors[0] theta_B = priors[1] #E step for observation in observations: len_observation = len(observation) #計算投擲次數 num_heads = observation.sum() #正面次數 num_tails = len_observation-num_heads #反面次數 #二項分配公式求解 contribution_A = scipy.stats.binom.pmf(num_heads,len_observation,theta_A) #Bin(x,n,p) contribution_B = scipy.stats.binom.pmf(num_heads,len_observation,theta_B) #計算在給定資料、當前參數下，資料來自哪個硬幣的機率 weight_A = contribution_A / (contribution_A + contribution_B) # p(y=1|x,theta) weight_B = contribution_B / (contribution_A + contribution_B) # p(y=0|x,theta) #更新在當前參數下A，B硬幣產生的正反面次數 counts['A']['H'] += weight_A * num_heads # num += 1 =&gt; num = num+1， sum p(y_i=1|x,theta)*x_i counts['A']['T'] += weight_A * num_tails counts['B']['H'] += weight_B * num_heads counts['B']['T'] += weight_B * num_tails # M step new_theta_A = counts['A']['H'] / (counts['A']['H'] + counts['A']['T']) #sum p(y_i=1|x,theta)*x_i / sum 10*p(y_i=1|x,theta) new_theta_B = counts['B']['H'] / (counts['B']['H'] + counts['B']['T']) #sum p(y_i=0|x,theta)*x_i / sum 10*p(y_i=1|x,theta) return [new_theta_A,new_theta_B] ###def em(observations,prior,tol = 1e-6,iterations=10000): \"\"\" EM算法 ：param observations :觀測數據 ：param prior：模型初始值 ：param tol：迭代结束阈值 ：param iterations：最大迭代次數 ：return：局部最佳的模型參數 \"\"\" iteration = 0; while iteration &lt; iterations: new_prior = em_single(prior,observations) delta_change = np.abs(prior[0]-new_prior[0]) if delta_change &lt; tol: break else: prior = new_prior iteration +=1 return new_prior,iterationprint (\"(p,q,iteration)=\",em(observations,[0.7,0.5])) Ans : (p,q,iteration)= ([0.79678865844706648, 0.51958340803243785], 12)","tags":[{"name":"EM","slug":"EM","permalink":"https://caocharles.github.io/tags/EM/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://caocharles.github.io/tags/Algorithm/"}],"categories":[{"name":"機器學習","slug":"machine-learning","permalink":"https://caocharles.github.io/categories/machine-learning/"}]},{"title":"我的測試文章","date":"2018-08-27T08:23:30.000Z","path":"我的測試文章/","text":"連結測試 打打看文字。 12345 1x+2y =5 $$\\sigma$$ $$\\frac{1}{2}$$ TENSORFLOW’S HELLO WORLD In this notebook we will overview the basics of TensorFlow, learn it’s structures and see what is the motivation to use it - How does TensorFlow work? - Building a Graph - Defining multidimensional arrays using TensorFlow - Why Tensors? - Variables - Placeholders - Operations—————-# How does TensorFlow work?TensorFlow’s capability to execute the code on different devices such as CPUs and GPUs is a consequence of it’s specific structure:TensorFlow defines computations as Graphs, and these are made with operations (also know as “ops”). So, when we work with TensorFlow, it is the same as defining a series of operations in a Graph.To execute these operations as computations, we must launch the Graph into a Session. The session translates and passes the operations represented into the graphs to the device you want to execute them on, be it a GPU or CPU.For example, the image below represents a graph in TensorFlow. _W_, _x_ and b are tensors over the edges of this graph. _MatMul_ is an operation over the tensors _W_ and _x_, after that _Add_ is called and add the result of the previous operator with _b_. The resultant tensors of each operation cross the next one until the end where it’s possible to get the wanted result.### Importing TensorFlowTo use TensorFlow, we need to import the library. We imported it and optionally gave it the name “tf”, so the modules can be accessed by tf.module-name:1import tensorflow as tf—————–# Building a GraphAs we said before, TensorFlow works as a graph computational model. Let’s create our first graph.To create our first graph we will utilize source operations, which do not need any information input. These source operations or source ops will pass their information to other operations which will execute computations.To create two source operations which will output numbers we will define two constants:12a = tf.constant([2])b = tf.constant([3])After that, let’s make an operation over these variables. The function tf.add() adds two elements (you could also use c = a + b).12c = tf.add(a,b)#c = a + b is also a way to define the sum of the termsThen TensorFlow needs to initialize a session to run our code. Sessions are, in a way, a context for creating a graph inside TensorFlow. Let’s define our session:1session = tf.Session()Let’s run the session to get the result from the previous defined ‘c’ operation:12result = session.run(c)print(result)Close the session to release resources:1session.close()To avoid having to close sessions every time, we can define them in a with block, so after running the with block the session will close automatically:123with tf.Session() as session: result = session.run(c) print(result)Even this silly example of adding 2 constants to reach a simple result defines the basis of TensorFlow. Define your edge (In this case our constants), include nodes (operations, like _tf.add_), and start a session to build a graph.### What is the meaning of Tensor?In TensorFlow all data is passed between operations in a computation graph, and these are passed in the form of Tensors, hence the name of TensorFlow.The word tensor from new latin means “that which stretches”. It is a mathematical object that is named tensor because an early application of tensors was the study of materials stretching under tension. The contemporary meaning of tensors can be taken as multidimensional arrays. That’s great, but… what are these multidimensional arrays? Going back a little bit to physics to understand the concept of dimensions: [Image Source] The zero dimension can be seen as a point, a single object or a single item. The first dimension can be seen as a line, a one-dimensional array can be seen as numbers along this line, or as points along the line. One dimension can contain infinite zero dimension/points elements. The second dimension can be seen as a surface, a two-dimensional array can be seen as an infinite series of lines along an infinite line. The third dimension can be seen as volume, a three-dimensional array can be seen as an infinite series of surfaces along an infinite line. The Fourth dimension can be seen as the hyperspace or spacetime, a volume varying through time, or an infinite series of volumes along an infinite line. And so forth on… As mathematical objects: [Image Source] Summarizing: Dimension Physical Representation Mathematical Object In Code Zero Point Scalar (Single Number) [ 1 ] One Line Vector (Series of Numbers) [ 1,2,3,4,… ] Two Surface Matrix (Table of Numbers) [ [1,2,3,4,…], [1,2,3,4,…], [1,2,3,4,…],… ] Three Volume Tensor (Cube of Numbers) [ [[1,2,…], [1,2,…], [1,2,…],…], [[1,2,…], [1,2,…], [1,2,…],…], [[1,2,…], [1,2,…], [1,2,…] ,…]… ] Defining multidimensional arrays using TensorFlowNow we will try to define such arrays using TensorFlow: 12345678910111213Scalar = tf.constant([2])Vector = tf.constant([5,6,2])Matrix = tf.constant([[1,2,3],[2,3,4],[3,4,5]])Tensor = tf.constant( [ [[1,2,3],[2,3,4],[3,4,5]] , [[4,5,6],[5,6,7],[6,7,8]] , [[7,8,9],[8,9,10],[9,10,11]] ] )with tf.Session() as session: result = session.run(Scalar) print (\"Scalar (1 entry):\\n %s \\n\" % result) result = session.run(Vector) print (\"Vector (3 entries) :\\n %s \\n\" % result) result = session.run(Matrix) print (\"Matrix (3x3 entries):\\n %s \\n\" % result) result = session.run(Tensor) print (\"Tensor (3x3x3 entries) :\\n %s \\n\" % result) Now that you understand these data structures, I encourage you to play with them using some previous functions to see how they will behave, according to their structure types: 12345678910111213Matrix_one = tf.constant([[1,2,3],[2,3,4],[3,4,5]])Matrix_two = tf.constant([[2,2,2],[2,2,2],[2,2,2]])first_operation = tf.add(Matrix_one, Matrix_two)second_operation = Matrix_one + Matrix_twowith tf.Session() as session: result = session.run(first_operation) print (\"Defined using tensorflow function :\") print(result) result = session.run(second_operation) print (\"Defined using normal expressions :\") print(result) With the regular symbol definition and also the TensorFlow function we were able to get an element-wise multiplication, also known as Hadamard product. But what if we want the regular matrix product? We then need to use another TensorFlow function called tf.matmul(): 123456789Matrix_one = tf.constant([[2,3],[3,4]])Matrix_two = tf.constant([[2,3],[3,4]])first_operation = tf.matmul(Matrix_one, Matrix_two)with tf.Session() as session: result = session.run(first_operation) print (\"Defined using tensorflow function :\") print(result) We could also define this multiplication ourselves, but there is a function that already does that, so no need to reinvent the wheel! Why Tensors?The Tensor structure helps us by giving the freedom to shape the dataset the way we want. And it is particularly helpful when dealing with images, due to the nature of how information in images are encoded, Thinking about images, its easy to understand that it has a height and width, so it would make sense to represent the information contained in it with a two dimensional strucutre (a matrix)… until you remember that images have colors, and to add information about the colors, we need another dimension, and thats when Tensors become particulary helpful. Images are encoded into color channels, the image data is represented into each color intensity in a color channel at a given point, the most common one being RGB, which means Red, Blue and Green. The information contained into an image is the intensity of each channel color into the width and height of the image, just like this: [Image Source] So the intensity of the red channel at each point with width and height can be represented into a matrix, the same goes for the blue and green channels, so we end up having three matrices, and when these are combined they form a tensor. VariablesNow that we are more familiar with the structure of data, we will take a look at how TensorFlow handles variables. To define variables we use the command tf.variable().To be able to use variables in a computation graph it is necessary to initialize them before running the graph in a session. This is done by running tf.global_variables_initializer(). To update the value of a variable, we simply run an assign operation that assigns a value to the variable: 1state = tf.Variable(0) Let’s first create a simple counter, a variable that increases one unit at a time: 123one = tf.constant(1)new_value = tf.add(state, one)update = tf.assign(state, new_value) Variables must be initialized by running an initialization operation after having launched the graph. We first have to add the initialization operation to the graph: 1init_op = tf.global_variables_initializer() We then start a session to run the graph, first initialize the variables, then print the initial value of the state variable, and then run the operation of updating the state variable and printing the result after each update: 123456with tf.Session() as session: session.run(init_op) print(session.run(state)) for _ in range(3): session.run(update) print(session.run(state)) PlaceholdersNow we know how to manipulate variables inside TensorFlow, but what about feeding data outside of a TensorFlow model? If you want to feed data to a TensorFlow model from outside a model, you will need to use placeholders. So what are these placeholders and what do they do? Placeholders can be seen as “holes” in your model, “holes” which you will pass the data to, you can create them using tf.placeholder(_datatype_), where _datatype_ specifies the type of data (integers, floating points, strings, booleans) along with its precision (8, 16, 32, 64) bits. The definition of each data type with the respective python sintax is defined as: Data type Python type Description DT_FLOAT tf.float32 32 bits floating point. DT_DOUBLE tf.float64 64 bits floating point. DT_INT8 tf.int8 8 bits signed integer. DT_INT16 tf.int16 16 bits signed integer. DT_INT32 tf.int32 32 bits signed integer. DT_INT64 tf.int64 64 bits signed integer. DT_UINT8 tf.uint8 8 bits unsigned integer. DT_STRING tf.string Variable length byte arrays. Each element of a Tensor is a byte array. DT_BOOL tf.bool Boolean. DT_COMPLEX64 tf.complex64 Complex number made of two 32 bits floating points: real and imaginary parts. DT_COMPLEX128 tf.complex128 Complex number made of two 64 bits floating points: real and imaginary parts. DT_QINT8 tf.qint8 8 bits signed integer used in quantized Ops. DT_QINT32 tf.qint32 32 bits signed integer used in quantized Ops. DT_QUINT8 tf.quint8 8 bits unsigned integer used in quantized Ops. [Table Source] So we create a placeholder: 1a = tf.placeholder(tf.float32) And define a simple multiplication operation: 1b = a*2 Now we need to define and run the session, but since we created a “hole” in the model to pass the data, when we initialize the session we are obligated to pass an argument with the data, otherwise we would get an error. To pass the data to the model we call the session with an extra argument feed_dict in which we should pass a dictionary with each placeholder name folowed by its respective data, just like this: 123with tf.Session() as sess: result = sess.run(b,feed_dict=&#123;a:3.5&#125;) print (result) Since data in TensorFlow is passed in form of multidimensional arrays we can pass any kind of tensor through the placeholders to get the answer to the simple multiplication operation: 12345dictionary=&#123;a: [ [ [1,2,3],[4,5,6],[7,8,9],[10,11,12] ] , [ [13,14,15],[16,17,18],[19,20,21],[22,23,24] ] ] &#125;with tf.Session() as sess: result = sess.run(b,feed_dict=dictionary) print (result) OperationsOperations are nodes that represent the mathematical operations over the tensors on a graph. These operations can be any kind of functions, like add and subtract tensor or maybe an activation function. _tf.matmul_, _tf.add_, _tf.nn.sigmoid_ are some of the operations in TensorFlow. These are like functions in python but operate directly over tensors and each one does a specific thing. Other operations can be easily found in: https://www.tensorflow.org/versions/r0.9/api_docs/python/index.html 12345678910a = tf.constant([5])b = tf.constant([2])c = tf.add(a,b)d = tf.subtract(a,b)with tf.Session() as session: result = session.run(c) print ('c =: %s' % result) result = session.run(d) print ('d =: %s' % result) _tf.nn.sigmoid_ is an activiation function, it’s a little more complicated, but this function helps learning models to evaluate what kind of information is good or not. Want to learn more?Running deep learning programs usually needs a high performance platform. PowerAI speeds up deep learning and AI. Built on IBM’s Power Systems, PowerAI is a scalable software platform that accelerates deep learning and AI with blazing performance for individual users or enterprises. The PowerAI platform supports popular machine learning libraries and dependencies including Tensorflow, Caffe, Torch, and Theano. You can download a free version of PowerAI. Also, you can use Data Science Experience to run these notebooks faster with bigger datasets. Data Science Experience is IBM’s leading cloud solution for data scientists, built by data scientists. With Jupyter notebooks, RStudio, Apache Spark and popular libraries pre-packaged in the cloud, DSX enables data scientists to collaborate on their projects without having to install anything. Join the fast-growing community of DSX users today with a free account at Data Science ExperienceThis is the end of this lesson. Hopefully, now you have a deeper and intuitive understanding regarding the LSTM model. Thank you for reading this notebook, and good luck on your studies. Thanks for completing this lesson!Notebook created by: Rafael Belo Da Silva References:https://www.tensorflow.org/versions/r0.9/get_started/index.htmlhttp://jrmeyer.github.io/tutorial/2016/02/01/TensorFlow-Tutorial.htmlhttps://www.tensorflow.org/versions/r0.9/api_docs/python/index.htmlhttps://www.tensorflow.org/versions/r0.9/resources/dims_types.htmlhttps://en.wikipedia.org/wiki/Dimensionhttps://book.mql4.com/variables/arrayshttps://msdn.microsoft.com/en-us/library/windows/desktop/dn424131(v=vs.85).aspx Copyright &copy; 2016 Big Data University. This notebook and its source code are released under the terms of the MIT License.","tags":[{"name":"這是標籤","slug":"這是標籤","permalink":"https://caocharles.github.io/tags/這是標籤/"},{"name":"這是標籤2","slug":"這是標籤2","permalink":"https://caocharles.github.io/tags/這是標籤2/"}],"categories":[{"name":"這是分類","slug":"這是分類","permalink":"https://caocharles.github.io/categories/這是分類/"},{"name":"這是子分類","slug":"這是分類/這是子分類","permalink":"https://caocharles.github.io/categories/這是分類/這是子分類/"}]},{"title":"Hello World","date":"2018-08-27T07:58:15.056Z","path":"hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[],"categories":[]}]}